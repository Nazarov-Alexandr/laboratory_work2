САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ МОРСКОЙ
ТЕХНИЧЕСКИЙ УНИВЕРСИТЕТ

КАФЕДРА КИБЕРФИЗИЧЕСКИХ СИСТЕМ



ОТЧЕТ

ПО ЛАБОРАТОРНОЙ РАБОТЕ № 2




Студент   Назаров А.И.                         Группа    20121


Выдано _________________                 Срок выполнения__________________



Зачет ___________________                  Дата ____________________________



                                                                  Преподаватель     Поделенюк П.П.



Цели работы:
1.	Дана квадратная шахматная доска размером N x N. На доске уже размещено К фигур.
 Фигуры размещены так, что находятся не под боем друг друга. Необходимо расставить на доске еще L фигур так,
  чтобы никакая из фигур на доске не находилась под боем любой другой фигуры.
2.	Необходимо найти все возможные решения.
3.	Входные данные в файле input.txt. На первой строке файла записаны три числа: N L K (через пробел).
Далее следует К строк, содержащих числа х и у (через пробел) – координаты уже стоящей на доске фигуры (фигуры стоят правильно).
Координаты отсчитываются от 0 до N-1. 1<=N<=20. Наш алгоритм должен быть оптимизирован для работы с доской 20.
4.	Выходные данные в файл output.txt. На каждое найденное решение необходимо записать в файл одну строку.
5.	Строка состоит из пар (х,у) – координаты фигур на доске. В решение следует вывести координаты всех фигур, находящихся на доске.
6.	Каждую фигуру необходимо записать в виде пары координат, разделённых запятой и обрамлённых скобками.
 Координаты отсчитываются от 0 до N-1. Порядок, в котором фигуры перечислены в решении, не имеет значения.
7.	Если не было найдено ни одного решения, в файл необходимо записать no solutions.
8.	Выходные данные на консоль – это доска N*N, где фигура обозначается #, её ходы обозначаются *, а пустые клетки обозначаются 0.
Задачи работы:
1.	Работа с текстовыми файлами
2.	Работа с локальными и глобальными переменными
3.	Работа с несколькими функциями, а не только main
4.	Нисходящий метод разработки программ
5.	Анализ ходов
Ход работы:
1. Создаём текстовый файл input.txt, в котором вводим исходные данные.
2. Открываем созданный текстовый файл при помощи with open и записываем его в переменную file.
3. Считываем содержимое file и записываем его в переменную lines с помощью file.readlines()
4.Разделяем lines на три числа N, L, K и координаты уже расставленных фигур и записываем это в переменные inp1 и inp2 соответственно.
5. Переносим значения из inp1 в переменные N, L и K соответственно.
6. Создаём доску при помощи генератора списков и записываем получившуюся систему в переменную board
7. Создаём множество и записываем его в переменную attacked_fields
8. При помощи цикла for, пройтись по каждой заранее введённой координате в радиусе К и записать её в переменные х и у
соответственно и отметить их в board, а также запустить функцию save_attacked_fields, в которую поступают:
 сторона доски N в качестве переменной n, координаты фигуры х и у, множество attacked_fields в качестве переменной attaсked
9. Делаем проверку на то, что координаты присутствуют в множестве attacked
10.Если условие выполнено, заканчиваем выполнение функции
11. Если условие не выполнено, добавляем координаты в множество attacked с помощью attacked.add((х,у))
12. Создаём переменную directions, в которую записываем кортеж, состоящий из кортежей – возможных ходов короля по горизонтали и вертикали.
13. При помощи цикла for пройтись по переменной directions, записывая координаты в переменные dx и dy
14. Находим соседние координаты от рассматриваемой в attacked
15.Делаем проверку на то, что координата не выходит за пределы доски
16. Если условие выполнено, то добавляем эту координату с помощью attacked.add((х1,у1))
17. При помощи цикла for пройтись по соседним диагональным клеткам, записывая координаты в dх и dy
18. Находим координаты по ходу движения слона
19. Используя встроенный цикл while проверяем координату на то, что она находится в пределах доски
20. Если условие выполняется, добавить эту координату в attacked с помощью attacked.add((х,у))
21. Переходим к следующей координате по направлению движения слона
22. Создаём список results
23. Запускаем таймер с помощью time()
24. Запускаем функцию searching, в которую поступает: доска board, сторона доски N, количество размещённых фигур placed,
равное нулю, количество фигур L, которое нужно разместить, список результатов results,
поля attacked, находящиеся под боем, начальные координаты хо и уо, равные нулю
25. Делаем проверку на то, что количество размещённых фигур placed совпадает с количеством фигур l, которое нужно разместить
26. Если условие выполнено, то при помощи генератора множеств создаём комбинацию comb
27. Проводим проверку на то, что комбинации comb нет в результате res
28. Если условие выполнено, добавляем получившуюся комбинацию в res с помощью res.append(list(comb))
29. Очищаем переменную attacked с помощью attacked.clear() и заканчиваем функцию
30. При помощи вложенных циклов for пройтись по каждой клетке доски в радиусе стороны этой доски
31. Делаем проверку на то, что это поле не находится под боем attaked
32. Если условие выполнено, делаем копию переменной attacked и записываем её в переменную attacked1
33. Ставим на доску фигуру board[х][у]=1
34. Запускаем функцию save_attacked_fields
35. Запускаем рекурсию функции searching с теми же параметрами кроме  placed+1
36. Убираем фигуру с доски
37. Возвращаем переменную attacked в исходное состояние
38. Запускаем новый таймер end
39. Распечатываем количество вариантов, параметры, время
40. Создаём текстовый файл output.txt, в котором будут записываться все полученные комбинации
41. Открываем файл output с помощью with open и записываем его в переменную file
42. При помощи цикла for пройтись по results и записать в файл полученные комбинации в отдельные строки
43. Если в results нет ни одной комбинации, то записываем в файл No solution
44. Если в results нет ни одной комбинации, то распечатываем No solution
45. При помощи проверки try вводим число s – количество досок с фигурами, которые мы хотим показать,
 и запускаем функцию showing, в которую поступают: число s в качестве переменной count,
  результаты results в качестве переменной combinations и сторона доски N в качестве переменной n
46. Если в переменную s было введено не число, то распечатываем No solutions
47. При помощи цикла for пройтись по каждой комбинации в пределах count
48. Делаем проверку на то, что i совпадает с count
49. Если условие выполнено, то заканчиваем функцию с помощью break
50. Распечатываем номер доски i+1
51. Создаём доску и записываем её в переменную desk
52. При помощи цикла for пройтись по каждой координате, в которой есть фигуры
53. В поле, где есть фигуры, заменить 0 на #
54. Запускаем функцию steps, в которую поступают: доска desk в качестве переменной board, сторона доски n в качестве переменной N, координаты х и у
55. Создаём переменную directions с вертикальными и горизонтальными ходами короля
56. При помощи цикла for пройтись по каждой координате из directions
57. находим координату соседнего горизонтального и вертикального поля и записываем её в переменную х1 и у1 соответственно
58. Проводим проверку на то, что полученная координата находится в пределах доски
59. Если условие выполнено, отмечаем эту координату *
60. При помощи цикла for пройтись по диагональным полям от рассматриваемой координаты
61. Находим координату, следующую по направлению слона, и записываем её в переменные х1 и у1 соответственно
62. Проводим проверку на то, что полученная координата находится в пределах доски с помощью цикла while
63. Если условие выполняется, то отмечаем эту координату *
64. Переходим к следующей координате по направлению движения слона
65. После завершения функции steps, используя цикл for, пройтись по полям desk
66. Распечатать получившуюся доску
Результаты работы:
Создана программа для решения задачи по заданному условию. Для проверки корректной работы программы зададим размер доски,
 определённое количество фигур, которые нужно расположить на доске и 2 уже расставленные фигуры с их координатами,
  удовлетворяющими условиям задачи. В результате проверка пройдена успешно.
Вывод:
Задание выполнено, цели работы достигнуты, программа работает корректно.









Листинг кода:
from time import time


def searching(board, n, placed, l, res, attacked, x0=0, y0=0):
    """поиск верных комбинаций"""
    if placed == l:
        comb = ((row, col) for row in range(0, n) for col in range(0, n) if board[row][col] == 1)
        if comb not in res:
            res.append(list(comb))
        attacked.clear()
        return
    # if len(attacked) == n**2:
        # print(len(attacked), x0, y0)
        # return
    for x in range(x0, n):
        for y in range(y0 + 1 if x == x0 else 0, n):
            if (x, y) not in attacked:
                attacked1 = attacked.copy()
                board[x][y] = 1
                save_attacked_fields(n, x, y, attacked)  # TODO реализовать проверку
                searching(board, n, placed + 1, l, res, attacked, x, y)
                board[x][y] = 0
                attacked = attacked1.copy()

def save_attacked_fields(n, x, y, attacked):
    """"""
    if (x, y) in attacked:
        return
    attacked.add((x, y))
    directions = ((0, 1), (1, 0), (0, -1), (-1, 0),)
    for dx, dy in directions:
        x1 = x + dx
        y1 = y + dy
        if 0 <= x1 < n and 0 <= y1 < n:
            attacked.add((x1, y1))
    for dx, dy in ((1, 1), (1, -1), (-1, -1), (-1, 1)):
        x1 = x + dx
        y1 = y + dy
        while 0 <= x1 < n and 0 <= y1 < n:
            attacked.add((x1, y1))
            x1 = x1 + dx
            y1 = y1 + dy

def steps(board, N, x, y):
    """отображение клеток, стоящих под боем"""
    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))
    for dx, dy in directions:
        x1 = x + dx
        y1 = y + dy
        if 0 <= x1 < N and 0 <= y1 < N:
            board[x1][y1] = "*"
    for dx, dy in ((1, 1), (1, -1), (-1, -1), (-1, 1)):
        x1 = x + dx
        y1 = y + dy
        while 0 <= x1 < N and 0 <= y1 < N:
            board[x1][y1] = "*"
            x1 = x1 + dx
            y1 = y1 + dy

def showing(count, combinations, n):
    """отображение поставленных фигур"""
    for i, comb in enumerate(combinations, 0):
        if count == i:
            break
        # print(comb)
        print(f"Комбинация {i + 1}")
        desk = creation(n)
        for x, y in comb:
            desk[x][y] = "#"
            steps(desk, n, x, y)
        for x in desk:
            print(" ".join(x))


def creation(n):
    """создание доски"""
    desk = [["0"] * n for i in range(n)]
    return desk


if __name__ == "__main__":
    with open("input.txt") as file:
        lines = file.readlines()
    inp1 = lines[0].split()
    inp2 = lines[1:]
    N = int(inp1[0])  #
    L = int(inp1[1])  #
    K = int(inp1[2])  #
    board = [[0]*N for i in range(N)]
    attacked_fields = set()
    for a in inp2[:K]:
        a = a.split()
        x = int(a[0])
        y = int(a[1])
        board[x][y] = 1
        save_attacked_fields(N, x, y, attacked_fields)
    results = []
    start = time()
    searching(board, N, 0, L, results, attacked_fields)
    end = time()
    print(f"Кол-во вариантов: {len(results)}, параметры: {N, L, K}, время: {round(end - start, 2)}")
    with open("output.txt", "w") as file:
        for result in results:
            # file.write(str(result))
            file.write(" ".join(f"{x, y}" for x, y in result))
            file.write("\n")
        if not results:
            file.write("No solution")
    if not results:
        print("No solution")
    try:
        s = int(input("количество досок с фигурами: "))
        showing(s, results, N)
    except:
        print("введены некорректные данные")


